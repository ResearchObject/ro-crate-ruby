<?xml version="1.0" encoding="UTF-8"?>
<config xmlns="http://www.knime.org/2008/09/XMLConfig" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.knime.org/2008/09/XMLConfig http://www.knime.org/XMLConfig_2008_09.xsd" key="settings.xml">
<entry key="node_file" type="xstring" value="settings.xml"/>
<config key="flow_stack"/>
<config key="internal_node_subsettings">
<entry key="memory_policy" type="xstring" value="CacheSmallInMemory"/>
</config>
<config key="model">
<entry key="sourceCode" type="xstring" value="&quot;&quot;&quot;Apply SMARTS reactions rules harvesting the power of RDKit and multiprocessing%%00010%%00010RetroSMARTS project.%%00010%%00010This script is intended to be used in a KNIME &quot;Python Script (2=&gt;1)&quot; node as a%%00010snippet.%%00010&quot;&quot;&quot;%%00010%%00010import os%%00010import sys%%00010import multiprocessing as mp%%00010import Queue as queue%%00010import signal%%00010%%00010from pandas import DataFrame%%00010from rdkit import Chem%%00010from rdkit.Chem import AllChem%%00010import psutil  # mostly to be Windows-friendly%%00010%%00010%%00010class WorkerApplyReactions(mp.Process):%%00010    &quot;&quot;&quot;A worker to apply reactions to some compounds.%%00010%%00010    Take tasks from input_queue, and put the results in the output_queue.%%00010    It has its own copy of all_cmpds (so watch out for memory issues).%%00010    The worker will die with a non-0 returncode if something wrong happenned.%%00010    &quot;&quot;&quot;%%00010%%00010    EX_LOSTPARENT = 2%%00010    EX_COMMUNICATIONERROR = 3%%00010    SENTINEL = &quot;cleanupandexit&quot;%%00010%%00010    def __init__(self, parent_pid, input_queue, output_queue, all_cmpds):%%00010        super(WorkerApplyReactions, self).__init__()%%00010        self.input_queue = input_queue%%00010        self.output_queue = output_queue%%00010        self.all_cmpds = all_cmpds%%00010        self.timeout_com = 10  # time after which a worker will die if it cannot communicate%%00010        self.parent_pid = parent_pid%%00010%%00010    def exit_immediately(self, exit_code):%%00010        os._exit(exit_code)  # legit after a fork%%00010%%00010    def _handler_signal(self, signum, frame):%%00010        self.exit_immediately(-1 * signum)%%00010%%00010    def is_parent_alive(self):%%00010        return psutil.pid_exists(self.parent_pid)%%00010%%00010    def apply_one_reaction_on_one_compound(self, idx_rxn, rxn, idx_sub, sub):%%00010        &quot;&quot;&quot;Applies one reaction on one compounds.&quot;&quot;&quot;%%00010        ans_list = []%%00010        predicted_prods_smi = set()%%00010        # Predict products%%00010        try:%%00010            predicted_prods = rxn.RunReactants([sub])%%00010        except ValueError as e:%%00010            # NB: occurs if not initialized properly (eg. wrong AAM)%%00010            raise%%00010        # Output each product in a new row%%00010        clock_res = 0%%00010        for x in predicted_prods:%%00010            pro = x[0]  # NB: products are all stored together as one compound%%00010            try:%%00010                pro_smiles = Chem.MolToSmiles(pro, kekuleSmiles=False, canonical=True)%%00010            except ValueError as e:%%00010                raise ValueError(&quot;{}: {}&quot;.format(pro, e))%%00010            # Is it a new product?%%00010            if pro_smiles and pro_smiles not in predicted_prods_smi:%%00010                predicted_prods_smi.add(pro_smiles)%%00010                # idx = &quot;{}_{}_{}&quot;.format(idx_rxn, idx_sub, clock_res)%%00010                idx = idx_rxn%%00010                clock_res += 1%%00010                ans = (idx, sub, pro)%%00010                ans_list.append(ans)%%00010        return ans_list%%00010%%00010    def run(self):%%00010        &quot;&quot;&quot;Apply all reactions on all compounds; reaction by reaction.&quot;&quot;&quot;%%00010        signal.signal(signal.SIGTERM, self._handler_signal)%%00010        while True:%%00010            if self.is_parent_alive():%%00010                try:%%00010                    ans = self.input_queue.get(block=True, timeout=self.timeout_com)%%00010                except queue.Empty:%%00010                    self.exit_immediately(self.EX_COMMUNICATIONERROR)%%00010            else:  # emergency exit%%00010                self.exit_immediately(self.EX_LOSTPARENT)%%00010            # Exit gracefully on sentinel%%00010            if ans == self.SENTINEL:%%00010                break%%00010            # Do some work%%00010            idx_rxn, smarts = ans%%00010            rxn = AllChem.ReactionFromSmarts(str(smarts))%%00010            for idx_sub, sub_smiles, sub in self.all_cmpds.itertuples():%%00010                ans = self.apply_one_reaction_on_one_compound(idx_rxn, rxn, idx_sub, sub)%%00010                if not self.is_parent_alive():%%00010                    break   # for conveniance: if daddy died, the data is lost anyway%%00010                try:%%00010                    self.output_queue.put(ans, block=True, timeout=self.timeout_com)%%00010                except queue.Full:%%00010                    # NB: we could also break and silently lose the compound%%00010                    self.exit_immediately(self.EX_COMMUNICATIONERROR)%%00010        pass  # job is finished: die gracefully with returncode=0%%00010%%00010%%00010class ParallelRDKit(object):%%00010    &quot;&quot;&quot;Handle a project in which we wish to call RDKit in parallel.%%00010%%00010    When KNIME dies, it tries to SIGTERM its childs and if it timeout, a SIGKILL%%00010    is sent. This class should deal with it so no process is left behind and%%00010    all memory is freed.%%00010%%00010    Watch out for two specific timeout:%%00010        - maximum time let for a worker to finish after:%%00010            - either finished his last task%%00010            - either receive a SIGTERM%%00010          it should be small.%%00010        - minimum time we wait a worker to produce results before SIGTERM it,%%00010          it should be reasonably high so the worker would be considered &quot;stalled&quot;.%%00010    &quot;&quot;&quot;%%00010%%00010    TIMEOUT_DYINGWORKER = 5%%00010    TIMEOUT_GETRESULTS = 600%%00010%%00010    def __init__(self, reactions, reactants, procs):%%00010        self.reactions = reactions  # [(&lt;ID&gt;, &lt;SMARTS&gt;), ...]%%00010        self.reactants = reactants  # [(&lt;ID&gt;, &lt;SMILES&gt;, &lt;RDKit obj.&gt;), ...]%%00010        self.n_allowed_processes = procs%%00010        self.todo_queue = None%%00010        self.output_queues = None%%00010        self.workers = None%%00010        self.results = None%%00010        self.pid = os.getpid()%%00010        self.parent_pid = psutil.Process(self.pid).ppid()%%00010        signal.signal(signal.SIGTERM, self._handler_signal)%%00010%%00010    def _exit_gracefully(self, exit_code=1):%%00010        # Terminate all children%%00010        # NB: children should handle the signal properly%%00010        for w in self.workers:%%00010            w.terminate()%%00010            w.join(self.TIMEOUT_DYINGWORKER)%%00010        # If any survived, force kill them%%00010        for w in self.workers:%%00010            if w.is_alive():%%00010                try:%%00010                    os.kill(w.pid, signal.SIGKILL)%%00010                except OSError:%%00010                    pass  # probably already dead%%00010            w.join(self.TIMEOUT_DYINGWORKER)%%00010        # Release all locks%%00010        self.todo_queue.cancel_join_thread()%%00010        for i in range(self.n_allowed_processes):%%00010            self.output_queues[i].cancel_join_thread()%%00010        # Suicide%%00010        sys.exit(exit_code)%%00010%%00010    def _handler_signal(self, signum, frame):%%00010        self._exit_gracefully(-1 * signum)%%00010%%00010    def _start_worker(self, i):%%00010        try:%%00010            self.workers[i] = WorkerApplyReactions(self.pid, self.todo_queue, self.done_queues[i], self.reactants)%%00010            self.workers[i].daemon = False  # wait for the kids to die before quitting (on normal exit)%%00010            self.workers[i].start()%%00010        except OSError as e:%%00010            # NB: happens if RAM is saturated%%00010            self._exit_gracefully()%%00010%%00010    def _init_workers(self):%%00010        &quot;&quot;&quot;Prepare input/output queues and start working.&quot;&quot;&quot;%%00010        # Prepare ONE shared queue of tasks%%00010        self.todo_queue = mp.Queue()%%00010        for r_id, r_smarts in self.reactions.itertuples():%%00010            args = (r_id, r_smarts)%%00010            self.todo_queue.put(args)%%00010        # Prepare each worker and their *respective* output queues%%00010        self.workers = [None] * self.n_allowed_processes%%00010        self.done_queues = [None] * self.n_allowed_processes%%00010        for i in range(self.n_allowed_processes):%%00010            self.todo_queue.put(WorkerApplyReactions.SENTINEL)%%00010            self.done_queues[i] = mp.Queue()%%00010            self._start_worker(i)%%00010%%00010    def _helper_save_results(self, ans):%%00010        &quot;&quot;&quot;Save the results loaded from an output queue.&quot;&quot;&quot;%%00010        if not self.results:%%00010            self.results = set()%%00010        for x in ans:%%00010            self.results.add(x)  # FIXME naive: results will accumulate in memory%%00010%%00010    def apply_all_reactions_on_all_reactants(self, timeout_result=None):%%00010        &quot;&quot;&quot;Uses RDKit and multiprocessing to predict products of reactions.%%00010%%00010        timeout_result: minimum time we wait a worker to produce results%%00010                        before SIGTERM it, it should be reasonably high so the%%00010                        worker would be considered &quot;stalled&quot;.%%00010        &quot;&quot;&quot;%%00010        if not timeout_result:%%00010            timeout_result = self.TIMEOUT_GETRESULTS%%00010        self._init_workers()%%00010        while True:%%00010            if self.todo_queue.empty() and all([q.empty() for q in self.done_queues]) and all([not w.is_alive() for w in self.workers]):%%00010                # nothing more to do%%00010                break%%00010            for i in range(self.n_allowed_processes):%%00010                # here is a worker%%00010                w = self.workers[i]%%00010                q = self.done_queues[i]%%00010                if not psutil.pid_exists(self.parent_pid):%%00010                    # parent process died =&gt; emergency exit%%00010                    self._exit_gracefully()%%00010                if q.empty() and w.is_alive():%%00010                    # No results? Give him a chance to die%%00010                    w.join(self.TIMEOUT_DYINGWORKER)%%00010                if not q.empty() or w.is_alive():%%00010                    # get or wait for his work%%00010                    try:%%00010                        ans = q.get(block=True, timeout=self.TIMEOUT_GETRESULTS)%%00010                        self._helper_save_results(ans)%%00010                    except queue.Empty:%%00010                        # worker is slow OR died while we were waiting%%00010                        if w.is_alive():%%00010                            # worker is indeed too slow, possibly stalled%%00010                            self.workers[i].terminate()%%00010                            w.join(self.TIMEOUT_DYINGWORKER)  # wait till death%%00010                if not self.todo_queue.empty() and not w.is_alive() and w.exitcode != 0:%%00010                    # there is work to do, but the worker has a non-normal death%%00010                    self._start_worker(i)  # ressurect!%%00010        pass%%00010%%00010%%00010def __called_from_command_line():%%00010    &quot;&quot;&quot;For DEBUG only.&quot;&quot;&quot;%%00010    import csv%%00010    # Import data%%00010    with open(&quot;dataport_1.csv&quot;, 'r') as d1, open(&quot;dataport_2.csv&quot;, 'r') as d2:%%00010        subs = DataFrame([(row[&quot;SMILES&quot;], Chem.MolFromSmiles(row[&quot;SMILES&quot;], sanitize=False)) for row in csv.DictReader(d1)])%%00010        rxns = DataFrame([(row[&quot;Rule&quot;],) for row in csv.DictReader(d2)])%%00010    # Work with worker%%00010    o = ParallelRDKit(rxns, subs, 4)%%00010    o.run()%%00010    print(o.results)%%00010%%00010%%00010def __called_within_knime():%%00010    &quot;&quot;&quot;Parse KNIME parameters carried either by the data connections or variables.%%00010%%00010    INPUT are global pandas DataFrame objects:%%00010        flow_variables%%00010        input_table_1%%00010        input_table_2%%00010    OUTPUT must be global pandas DataFrame object:%%00010        output_table%%00010    &quot;&quot;&quot;%%00010    # Get KNIME input from hidden global variables%%00010    subs = input_table_1.loc[:, ('SMILES', 'Compound')]  # reactants; DataFrame([[&lt;RowID&gt;, &lt;SMILES&gt;, &lt;RDKit objects&gt;], ...])%%00010    rxns = input_table_2.loc[:, ('Rule',)]  # DataFrame([(&lt;RowID&gt;, &lt;str SMARTS&gt;), ...])%%00010    timeout = flow_variables['dev.py-fire-timeout']  # timeout for getting results from an output_queue%%00010    n_processes = flow_variables['dev.py-fire-procs']  # number of parallel processes%%00010    # Start working%%00010    o = ParallelRDKit(rxns, subs, n_processes)%%00010    o.apply_all_reactions_on_all_reactants(timeout)%%00010    # Set the KNIME output (must be global and called &quot;output_table&quot;)%%00010    global output_table%%00010    if o.results:%%00010        rows = []%%00010        for ans in o.results:%%00010            row = {&quot;RowID&quot;: ans[0], &quot;Product&quot;: ans[2], &quot;Reactant 1&quot;: ans[1]}%%00010            rows.append(row)%%00010        output_table = DataFrame(rows)%%00010    else:  # no results at all%%00010        output_table = DataFrame(columns=[&quot;RowID&quot;, &quot;Product&quot;, &quot;Reactant 1&quot;])%%00010%%00010%%00010if __name__ == &quot;__main__&quot;:%%00010    raise NotImplementedError(&quot;The cake is a lie.&quot;)%%00010    __called_from_command_line()%%00010elif __name__ == &quot;__builtin__&quot;:%%00010    __called_within_knime()%%00010"/>
<entry key="rowLimit" type="xint" value="1000"/>
</config>
<config key="nodeAnnotation">
<entry key="text" type="xstring" value="Fire rules using Python"/>
<entry key="bgcolor" type="xint" value="16777215"/>
<entry key="x-coordinate" type="xint" value="325"/>
<entry key="y-coordinate" type="xint" value="539"/>
<entry key="width" type="xint" value="150"/>
<entry key="height" type="xint" value="17"/>
<entry key="alignment" type="xstring" value="CENTER"/>
<entry key="borderSize" type="xint" value="0"/>
<entry key="borderColor" type="xint" value="16777215"/>
<entry key="defFontSize" type="xint" value="11"/>
<entry key="annotation-version" type="xint" value="20151123"/>
<config key="styles"/>
</config>
<entry key="customDescription" type="xstring" isnull="true" value=""/>
<entry key="state" type="xstring" value="IDLE"/>
<entry key="factory" type="xstring" value="org.knime.python.nodes.script2in1out.PythonScript2In1OutNodeFactory"/>
<entry key="node-name" type="xstring" value="Python Script (2⇒1) (deprecated)"/>
<entry key="node-bundle-name" type="xstring" value="KNIME Python nodes"/>
<entry key="node-bundle-symbolic-name" type="xstring" value="org.knime.python.nodes"/>
<entry key="node-bundle-vendor" type="xstring" value="KNIME AG, Zurich, Switzerland"/>
<entry key="node-bundle-version" type="xstring" value="3.6.0.v201807051517"/>
<entry key="node-feature-name" type="xstring" value="KNIME Python Integration (deprecated)"/>
<entry key="node-feature-symbolic-name" type="xstring" value="org.knime.features.python.feature.group"/>
<entry key="node-feature-vendor" type="xstring" value="KNIME AG, Zurich, Switzerland"/>
<entry key="node-feature-version" type="xstring" value="3.6.1.v201808311614"/>
<config key="factory_settings"/>
<entry key="name" type="xstring" value="Python Script (2⇒1) (deprecated)"/>
<entry key="hasContent" type="xboolean" value="false"/>
<entry key="isInactive" type="xboolean" value="false"/>
<config key="ports">
<config key="port_1">
<entry key="index" type="xint" value="1"/>
<entry key="port_dir_location" type="xstring" isnull="true" value=""/>
</config>
</config>
<config key="filestores">
<entry key="file_store_location" type="xstring" isnull="true" value=""/>
<entry key="file_store_id" type="xstring" isnull="true" value=""/>
</config>
</config>
